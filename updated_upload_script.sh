#!/bin/bash
# Script automatizado para upload do Bot Trading para GitHub
# Vers√£o atualizada com suporte a reposit√≥rio PRIVADO e verifica√ß√µes melhoradas

set -e  # Parar se qualquer comando falhar

echo "üöÄ BOT TRADING BINANCE - UPLOAD PARA GITHUB PRIVADO"
echo "=================================================="

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# Fun√ß√£o para print colorido
print_status() {
    case $2 in
        "error") echo -e "${RED}‚ùå $1${NC}" ;;
        "success") echo -e "${GREEN}‚úÖ $1${NC}" ;;
        "warning") echo -e "${YELLOW}‚ö†Ô∏è $1${NC}" ;;
        "info") echo -e "${BLUE}‚ÑπÔ∏è $1${NC}" ;;
        "private") echo -e "${PURPLE}üîí $1${NC}" ;;
        *) echo "$1" ;;
    esac
}

# Verificar se estamos no diret√≥rio correto
if [ ! -f "main.py" ]; then
    print_status "Erro: main.py n√£o encontrado. Execute no diret√≥rio do projeto!" "error"
    exit 1
fi

print_status "Verificando projeto Bot Trading..." "info"

# 1. VERIFICA√á√ïES DE SEGURAN√áA MELHORADAS
echo ""
echo "üîê 1. VERIFICA√á√ïES DE SEGURAN√áA"
echo "================================"

# Fun√ß√£o para verificar API keys - melhorada para ser mais espec√≠fica
check_api_keys() {
    local found_issues=false
    
    print_status "Verificando API keys Binance..." "info"
    
    # Padr√µes espec√≠ficos para Binance e outras APIs
    local patterns=(
        # Binance API keys reais (64 caracteres alfanum√©ricos)
        'api_key.*[=:].*["\'"'"'][A-Za-z0-9]{60,70}["\'"'"']'
        'secret.*[=:].*["\'"'"'][A-Za-z0-9/+=]{60,70}["\'"'"']'
        'API_KEY.*[=:].*["\'"'"'][A-Za-z0-9]{60,70}["\'"'"']'
        'SECRET.*[=:].*["\'"'"'][A-Za-z0-9/+=]{60,70}["\'"'"']'
        
        # Tokens diversos longos
        'token.*[=:].*["\'"'"'][A-Za-z0-9_-]{40,}["\'"'"']'
        'TOKEN.*[=:].*["\'"'"'][A-Za-z0-9_-]{40,}["\'"'"']'
        
        # Padr√µes de chaves privadas
        '-----BEGIN.*PRIVATE KEY-----'
        'sk-[A-Za-z0-9]{20,}'
        
        # Senhas em configura√ß√µes
        'password.*[=:].*["\'"'"'][^Y][^O][^U][^R].*["\'"'"']'
    )
    
    for pattern in "${patterns[@]}"; do
        if grep -r -E "$pattern" . --exclude-dir=.git --exclude-dir=venv --exclude-dir=__pycache__ --exclude="*.log" --exclude="*.db" 2>/dev/null; then
            print_status "PERIGO: Poss√≠vel API key/senha real encontrada!" "error"
            echo "Padr√£o detectado: $pattern"
            found_issues=true
        fi
    done
    
    # Verificar especificamente arquivos que n√£o devem ter keys reais
    local config_files=("config/settings.yaml" "config.yaml" ".env" "main.py")
    for file in "${config_files[@]}"; do
        if [ -f "$file" ]; then
            # Buscar por keys que N√ÉO sejam placeholders
            if grep -E "(api_key|secret).*[=:].*[\"'][A-Za-z0-9]{50,}[\"']" "$file" 2>/dev/null | grep -v -E "(YOUR_|EXAMPLE_|TEST_|PLACEHOLDER)" > /dev/null; then
                print_status "ATEN√á√ÉO: $file pode conter API key real!" "warning"
                echo "Verifique se as keys s√£o placeholders ou exemplos"
                found_issues=true
            fi
        fi
    done
    
    if [ "$found_issues" = true ]; then
        return 1
    else
        return 0
    fi
}

# Verificar configura√ß√µes de produ√ß√£o perigosas
check_production_config() {
    local suspicious_terms=(
        'mode.*[=:].*["\'"'"']real["\'"'"']'
        'testnet.*[=:].*false'
        'production.*[=:].*true'
        'live_trading.*[=:].*true'
        'real_trading.*[=:].*true'
    )
    
    print_status "Verificando configura√ß√µes de produ√ß√£o..." "info"
    
    for term in "${suspicious_terms[@]}"; do
        if grep -r -i -E "$term" . --exclude-dir=.git --exclude-dir=venv --exclude-dir=__pycache__ 2>/dev/null; then
            print_status "ATEN√á√ÉO: Configura√ß√£o de modo REAL encontrada!" "warning"
            echo "Termo encontrado: $term"
            echo "Para reposit√≥rio privado, isso pode ser aceit√°vel."
            return 1
        fi
    done
    return 0
}

# Executar verifica√ß√µes de seguran√ßa
print_status "üîç Executando verifica√ß√µes de seguran√ßa..." "info"

if ! check_api_keys; then
    echo ""
    print_status "‚ùå VERIFICA√á√ÉO DE API KEYS FALHOU" "error"
    echo ""
    echo "üìã Solu√ß√µes recomendadas:"
    echo "1. Mova API keys para arquivo .env (n√£o versionado)"
    echo "2. Use vari√°veis de ambiente do sistema"
    echo "3. Use placeholders como 'YOUR_API_KEY_HERE'"
    echo "4. Configure arquivo separado em .gitignore"
    echo ""
    
    read -p "üîí Como o reposit√≥rio ser√° PRIVADO, deseja continuar? (y/N): " continue_with_keys
    if [[ $continue_with_keys != [yY] ]]; then
        print_status "Upload cancelado para prote√ß√£o" "info"
        exit 1
    fi
    print_status "CONTINUANDO (reposit√≥rio privado protege as keys)" "warning"
else
    print_status "Nenhuma API key real encontrada" "success"
fi

if ! check_production_config; then
    echo ""
    read -p "üîí Configura√ß√£o de produ√ß√£o detectada. Continuar com reposit√≥rio privado? (y/N): " continue_prod
    if [[ $continue_prod != [yY] ]]; then
        print_status "Upload cancelado" "info"
        exit 1
    fi
    print_status "CONTINUANDO (reposit√≥rio privado √© seguro)" "warning"
else
    print_status "Configura√ß√µes seguras detectadas" "success"
fi

# 2. ORGANIZAR ESTRUTURA DO PROJETO
echo ""
echo "üìÅ 2. ORGANIZANDO ESTRUTURA DO PROJETO"
echo "======================================"

# Detectar arquivos com prefixo trading_bot_ e organizar
organize_trading_bot_files() {
    local files_to_organize=($(ls trading_bot_* 2>/dev/null || true))
    
    if [ ${#files_to_organize[@]} -gt 0 ]; then
        print_status "Detectados ${#files_to_organize[@]} arquivos com prefixo 'trading_bot_'" "info"
        
        echo ""
        echo "üìã Arquivos detectados:"
        for file in "${files_to_organize[@]}"; do
            echo "  - $file"
        done
        
        echo ""
        read -p "üîß Deseja remover o prefixo 'trading_bot_' e organizar automaticamente? (Y/n): " auto_organize
        
        if [[ $auto_organize != [nN] ]]; then
            print_status "Organizando arquivos automaticamente..." "info"
            
            # Mapeamento de arquivos para diret√≥rios corretos
            declare -A file_mapping=(
                ["trading_bot_core.py"]="core/trading_bot.py"
                ["trading_bot_executor.py"]="core/executor.py"
                ["trading_bot_risk.py"]="core/risk_manager.py"
                ["trading_bot_binance.py"]="infrastructure/binance_api.py"
                ["trading_bot_indicators.py"]="infrastructure/indicators.py"
                ["trading_bot_data.py"]="infrastructure/data_manager.py"
                ["trading_bot_config.yaml"]="config/settings.yaml"
                ["trading_bot_config_loader.py"]="config/config_loader.py"
                ["trading_bot_database.py"]="database/db_handler.py"
                ["trading_bot_dashboard.py"]="interface/simple_dashboard.py"
                ["trading_bot_backtest.py"]="backtest/validator.py"
                ["trading_bot_quickstart.md"]="docs/QUICKSTART.md"
                ["trading_bot_api_guide.md"]="docs/BINANCE_API_SETUP.md"
                ["trading_bot_readme.md"]="README.md"
                ["trading_bot_requirements.txt"]="requirements.txt"
                ["trading_bot_test.py"]="test_setup.py"
            )
            
            # Criar diret√≥rios necess√°rios
            mkdir -p core infrastructure config database interface backtest docs data logs
            
            # Mover e renomear arquivos
            for old_file in "${files_to_organize[@]}"; do
                if [[ -v file_mapping["$old_file"] ]]; then
                    new_path="${file_mapping[$old_file]}"
                    
                    # Criar diret√≥rio se n√£o existir
                    mkdir -p "$(dirname "$new_path")"
                    
                    # Mover arquivo
                    mv "$old_file" "$new_path"
                    print_status "Movido: $old_file ‚Üí $new_path" "success"
                else
                    # Remover prefixo apenas
                    new_name="${old_file#trading_bot_}"
                    mv "$old_file" "$new_name"
                    print_status "Renomeado: $old_file ‚Üí $new_name" "success"
                fi
            done
            
            print_status "Organiza√ß√£o autom√°tica conclu√≠da!" "success"
        else
            print_status "Pulando organiza√ß√£o autom√°tica" "info"
        fi
    else
        print_status "Nenhum arquivo com prefixo 'trading_bot_' encontrado" "info"
    fi
}

# Executar organiza√ß√£o
organize_trading_bot_files

# Estrutura esperada do projeto
declare -A expected_structure=(
    ["core/"]="L√≥gica principal do bot"
    ["infrastructure/"]="APIs, WebSocket e indicadores"
    ["config/"]="Configura√ß√µes e carregadores" 
    ["database/"]="Banco de dados e persist√™ncia"
    ["interface/"]="Dashboard e interface"
    ["backtest/"]="Sistema de backtesting"
    ["data/"]="Dados hist√≥ricos e cache"
    ["logs/"]="Arquivos de log"
    ["docs/"]="Documenta√ß√£o do projeto"
)

print_status "Verificando estrutura de diret√≥rios..." "info"

# Criar diret√≥rios necess√°rios
missing_dirs=()
for dir in "${!expected_structure[@]}"; do
    if [ -d "$dir" ]; then
        print_status "$dir existe ‚úì" "success"
    else
        mkdir -p "$dir"
        missing_dirs+=("$dir")
        print_status "Criado: $dir" "success"
    fi
done

# Criar arquivos __init__.py
python_dirs=("core" "infrastructure" "config" "database" "interface" "backtest")
print_status "Verificando arquivos __init__.py..." "info"

for dir in "${python_dirs[@]}"; do
    if [ ! -f "$dir/__init__.py" ]; then
        touch "$dir/__init__.py"
        print_status "Criado: $dir/__init__.py" "success"
    else
        print_status "$dir/__init__.py j√° existe ‚úì" "success"
    fi
done

# Criar .gitkeep em diret√≥rios que devem ser mantidos vazios
empty_dirs=("data" "logs")
for dir in "${empty_dirs[@]}"; do
    if [ -d "$dir" ] && [ ! -f "$dir/.gitkeep" ]; then
        echo "# Manter diret√≥rio no git" > "$dir/.gitkeep"
        print_status "Criado: $dir/.gitkeep" "success"
    fi
done

# 3. CONFIGURAR .GITIGNORE PARA REPOSIT√ìRIO PRIVADO
echo ""
echo "üö´ 3. CONFIGURANDO .GITIGNORE PARA REPOSIT√ìRIO PRIVADO"
echo "======================================================"

if [ ! -f ".gitignore" ]; then
    cat > .gitignore << 'EOF'
# Bot Trading Binance - .gitignore para Reposit√≥rio Privado

# ========================================
# DADOS SENS√çVEIS (mesmo em repo privado)
# ========================================
# Configura√ß√µes locais com dados reais
.env
.env.local
.env.production
config/local_settings.yaml
config/production_secrets.yaml

# Logs com dados sens√≠veis
logs/trades_*.log
logs/api_*.log
logs/sensitive_*.log

# Backups de banco com dados reais
data/production_*.db
data/live_*.sqlite
backups/

# ========================================
# ARQUIVOS DE DESENVOLVIMENTO
# ========================================
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual Environment
venv/
env/
ENV/
.venv/
.virtualenv

# ========================================
# DADOS E LOGS OPERACIONAIS
# ========================================
# Dados de trading (podem ser grandes)
data/*.csv
data/historical_*.json
data/cache/
data/temp/

# Logs operacionais
logs/*.log
logs/daily/
logs/backtest/

# Resultados de backtest
backtest/results/
backtest/reports/
backtest/temp/

# ========================================
# IDE E FERRAMENTAS
# ========================================
# VSCode
.vscode/
*.code-workspace

# PyCharm
.idea/
*.iml
*.ipr
*.iws

# Vim
*.swp
*.swo
*~

# Emacs
*~
\#*\#
/.emacs.desktop
/.emacs.desktop.lock
*.elc
auto-save-list
tramp
.\#*

# ========================================
# SISTEMA OPERACIONAL
# ========================================
# Windows
Thumbs.db
Desktop.ini
$RECYCLE.BIN/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Linux
*~
.fuse_hidden*
.directory
.Trash-*
.nfs*

# ========================================
# ARQUIVOS TEMPOR√ÅRIOS
# ========================================
# Tempor√°rios gerais
temp/
tmp/
*.tmp
*.temp
*.bak
*.backup
*.old
*.orig

# Arquivos de teste
test_*.py
debug_*.py
sandbox/
experiments/

# ========================================
# CONFIGURA√á√ïES ESPEC√çFICAS
# ========================================
# Certificados e chaves
*.pem
*.key
*.cert
*.crt

# Arquivos de configura√ß√£o local
local_config.*
my_settings.*
personal_*.yaml

# Scripts pessoais
run_local.*
deploy_personal.*

# Notas e documentos pessoais
notes.txt
todo.txt
personal_notes/
EOF
    print_status ".gitignore criado para reposit√≥rio privado" "success"
else
    print_status ".gitignore j√° existe" "info"
    
    # Verificar se tem configura√ß√µes adequadas para reposit√≥rio privado
    if ! grep -q "REPOSIT√ìRIO PRIVADO" .gitignore 2>/dev/null; then
        echo ""
        read -p "üîß Deseja atualizar .gitignore para reposit√≥rio privado? (Y/n): " update_gitignore
        if [[ $update_gitignore != [nN] ]]; then
            cp .gitignore .gitignore.backup
            cat > .gitignore << 'EOF'
# Bot Trading Binance - .gitignore para Reposit√≥rio Privado
# (Backup do original salvo como .gitignore.backup)

# Dados sens√≠veis (mesmo em repo privado)
.env
.env.local
.env.production
config/local_settings.yaml
config/production_secrets.yaml

# Python b√°sico
__pycache__/
*.py[cod]
venv/
.venv/

# Dados operacionais
data/*.db
data/*.sqlite
data/*.csv
logs/*.log
backtest/results/

# IDE
.vscode/
.idea/
*.swp

# OS
.DS_Store
Thumbs.db

# Tempor√°rios
temp/
tmp/
*.tmp
*.bak
EOF
            print_status ".gitignore atualizado (backup salvo)" "success"
        fi
    fi
fi

# 4. VERIFICAR ARQUIVOS ESSENCIAIS
echo ""
echo "üìã 4. VERIFICANDO ARQUIVOS ESSENCIAIS"
echo "====================================="

essential_files=(
    "main.py"
    "requirements.txt"
    "README.md"
    ".gitignore"
)

missing_files=()
for file in "${essential_files[@]}"; do
    if [ -f "$file" ]; then
        print_status "$file existe ‚úì" "success"
    else
        print_status "$file N√ÉO EXISTE" "error"
        missing_files+=("$file")
    fi
done

if [ ${#missing_files[@]} -ne 0 ]; then
    print_status "Criando arquivos essenciais faltantes..." "warning"
    
    for file in "${missing_files[@]}"; do
        case $file in
            "requirements.txt")
                cat > requirements.txt << 'EOF'
# Bot de Trading Binance V5.1 - Depend√™ncias

# Core
python-binance==1.0.17
pandas==2.0.0
numpy==1.24.0

# Configura√ß√£o
PyYAML==6.0

# Async e WebSocket
websockets==11.0
aiohttp==3.8.0

# Interface
rich==13.0.0

# Teclado
keyboard==0.13.5
EOF
                print_status "requirements.txt criado" "success"
                ;;
            "README.md")
                cat > README.md << 'EOF'
# ü§ñ Bot de Trading Binance V5.1

Bot automatizado de day trading para Binance.

## üîí Reposit√≥rio Privado

Este √© um reposit√≥rio privado com c√≥digo propriet√°rio de trading.

## üöÄ Caracter√≠sticas

- Estrat√©gia RSI + Bollinger Bands + EMA
- WebSocket para execu√ß√£o r√°pida
- Dashboard terminal
- Sistema de backtest
- Gest√£o de risco autom√°tica

## ‚ö†Ô∏è Importante

- **SEMPRE** teste no testnet primeiro
- **NUNCA** use mais dinheiro do que pode perder
- Configure adequadamente suas API keys

## üîß Instala√ß√£o

```bash
pip install -r requirements.txt
python main.py
```
EOF
                print_status "README.md criado" "success"
                ;;
        esac
    done
fi

# 5. CONFIGURAR GIT
echo ""
echo "üîß 5. CONFIGURANDO GIT"
echo "====================="

if [ ! -d ".git" ]; then
    git init
    print_status "Reposit√≥rio git inicializado" "success"
else
    print_status "Reposit√≥rio git j√° existe" "info"
fi

# Configurar git se necess√°rio
if ! git config --get user.name > /dev/null; then
    echo ""
    read -p "üìù Digite seu nome para o git: " git_name
    git config --global user.name "$git_name"
    print_status "Nome configurado: $git_name" "success"
fi

if ! git config --get user.email > /dev/null; then
    echo ""
    read -p "üìß Digite seu email para o git: " git_email
    git config --global user.email "$git_email"
    print_status "Email configurado: $git_email" "success"
fi

# 6. COMMIT
echo ""
echo "üíæ 6. PREPARANDO E EXECUTANDO COMMIT"
echo "===================================="

# Adicionar arquivos
git add .

# Verificar status
files_count=$(git diff --cached --name-only | wc -l)
print_status "$files_count arquivos ser√£o commitados" "info"

# Mostrar principais arquivos
echo ""
echo "üìÑ Principais arquivos no commit:"
git diff --cached --name-only | grep -E "\.(py|yaml|md|txt)$" | head -8
if [ $files_count -gt 8 ]; then
    echo "... e mais $((files_count - 8)) arquivos"
fi

# Commit com mensagem espec√≠fica para reposit√≥rio privado
commit_message="üîí Initial commit: Bot Trading Binance V5.1 (Private Repository)

‚ú® Features implementadas:
- Trading automatizado com estrat√©gia RSI + Bollinger Bands + EMA
- WebSocket para execu√ß√£o em tempo real (<100ms lat√™ncia)
- Dashboard terminal minimalista com controles interativos
- Sistema de backtest e valida√ß√£o autom√°tica
- Gest√£o de risco avan√ßada com circuit breakers
- Suporte completo ao Binance Testnet e produ√ß√£o

üèóÔ∏è Arquitetura:
- 10 m√≥dulos principais organizados
- Configura√ß√£o YAML flex√≠vel
- Banco de dados SQLite para persist√™ncia
- Interface Rich terminal responsiva
- Documenta√ß√£o completa inclu√≠da

üîê Reposit√≥rio Privado:
- Cont√©m configura√ß√µes propriet√°rias
- API keys e segredos protegidos
- Estrat√©gias de trading exclusivas
- C√≥digo otimizado para performance

‚ö†Ô∏è AVISOS DE SEGURAN√áA:
- Sempre validar no testnet antes de produ√ß√£o
- Nunca usar mais capital do que pode perder
- Monitorar trades constantemente
- Manter API keys seguras

üéØ Pr√≥ximos passos:
1. Configurar API keys no ambiente
2. Executar testes de configura√ß√£o  
3. Validar estrat√©gia no testnet
4. Implementar monitoramento cont√≠nuo"

git commit -m "$commit_message"
print_status "Commit realizado com sucesso" "success"

# 7. CONFIGURAR REPOSIT√ìRIO PRIVADO NO GITHUB
echo ""
echo "üîí 7. CONFIGURANDO REPOSIT√ìRIO PRIVADO NO GITHUB"
echo "==============================================="

print_status "Configura√ß√£o para reposit√≥rio PRIVADO" "private"

if git remote get-url origin >/dev/null 2>&1; then
    current_remote=$(git remote get-url origin)
    print_status "Remote j√° configurado: $current_remote" "info"
else
    echo ""
    print_status "Instru√ß√µes para criar reposit√≥rio PRIVADO:" "private"
    echo ""
    echo "üåê 1. Acesse: https://github.com/new"
    echo "üìù 2. Nome: trading-bot-binance-private (ou similar)"
    echo "üìã 3. Descri√ß√£o: ü§ñüîí Bot automatizado de day trading - Reposit√≥rio Privado"
    echo "üîí 4. ‚úÖ PRIVATE (muito importante!)"
    echo "üìÑ 5. ‚ùå N√ÉO adicione README/gitignore (j√° temos)"
    echo "üë§ 6. Configure colaboradores se necess√°rio"
    echo ""
    echo "üîê Vantagens do reposit√≥rio privado:"
    echo "  - API keys protegidas"
    echo "  - Estrat√©gias propriet√°rias seguras"
    echo "  - Configura√ß√µes sens√≠veis protegidas"
    echo "  - Controle total de acesso"
    echo ""
    
    read -p "üìé Digite a URL do reposit√≥rio PRIVADO: " repo_url
    
    git remote add origin "$repo_url"
    print_status "Remote configurado para reposit√≥rio privado" "private"
fi

# 8. UPLOAD PARA REPOSIT√ìRIO PRIVADO
echo ""
echo "üöÄ 8. FAZENDO UPLOAD PARA REPOSIT√ìRIO PRIVADO"
echo "============================================="

print_status "Iniciando upload para reposit√≥rio privado..." "private"

# Configurar branch principal
current_branch=$(git branch --show-current 2>/dev/null || echo "master")
if [ "$current_branch" != "main" ]; then
    git branch -M main
    print_status "Branch renomeada para 'main'" "info"
fi

# Push para GitHub
echo ""
print_status "üîê Fazendo push para reposit√≥rio privado..." "private"

if git push -u origin main; then
    print_status "Upload para reposit√≥rio privado conclu√≠do!" "success"
else
    print_status "Erro no upload. Verificando solu√ß√µes..." "error"
    echo ""
    echo "üîß Solu√ß√µes para autentica√ß√£o:"
    echo "1. üé´ Personal Access Token: https://github.com/settings/tokens"
    echo "   - Scopes necess√°rios: repo (acesso total a reposit√≥rios privados)"
    echo "2. üîë SSH Keys: https://github.com/settings/keys" 
    echo "3. üåê GitHub CLI: gh auth login"
    echo "4. üíª Git Credential Manager"
    echo ""
    read -p "üîÑ Tentar push novamente? (y/N): " retry_push
    if [[ $retry_push == [yY] ]]; then
        git push -u origin main
    else
        echo "Execute manualmente: git push -u origin main"
        exit 1
    fi
fi

# 9. VERIFICA√á√ïES FINAIS E SEGURAN√áA
echo ""
echo "‚úÖ 9. VERIFICA√á√ïES FINAIS DO REPOSIT√ìRIO PRIVADO"
echo "==============================================="

repo_url=$(git remote get-url origin)
if [[ $repo_url == *"github.com"* ]]; then
    browser_url="${repo_url%.git}"
    browser_url="${browser_url/git@github.com:/https://github.com/}"
    
    print_status "Reposit√≥rio privado dispon√≠vel em: $browser_url" "private"
fi

echo ""
echo "üéâ REPOSIT√ìRIO PRIVADO CRIADO COM SUCESSO!"
echo "========================================="
echo ""
print_status "üîí Seu bot est√° seguro em reposit√≥rio privado!" "private"
echo ""
echo "üìã Pr√≥ximos passos essenciais:"
echo ""
echo "üîê 1. SEGURAN√áA:"
echo "   - Configure colaboradores em Settings > Manage access"
echo "   - Ative 2FA na sua conta GitHub"
echo "   - Configure branch protection rules"
echo ""
echo "‚öôÔ∏è 2. CONFIGURA√á√ÉO:"
echo "   - Clone em ambiente de desenvolvimento"
echo "   - Configure API keys localmente"
echo "   - Execute testes no testnet"
echo ""
echo "üìä 3. OPERA√á√ÉO:"
echo "   - Valide estrat√©gia por semanas no testnet"
echo "   - Monitore performance constantemente"
echo "   - Mantenha backups das configura√ß√µes"
echo ""
echo "üö® 4. AVISOS IMPORTANTES:"
echo "   - NUNCA torne o reposit√≥rio p√∫blico"
echo "   - SEMPRE teste antes de usar dinheiro real"
echo "   - MONITORE trades constantemente"
echo "   - MANTENHA logs de todas as opera√ß√µes"
echo ""

# Teste de clone (opcional)
echo ""
read -p "üß™ Deseja testar clone do reposit√≥rio privado? (y/N): " test_clone
if [[ $test_clone == [yY] ]]; then
    test_dir="/tmp/trading-bot-private-test"
    rm -rf "$test_dir" 2>/dev/null
    
    if git clone "$repo_url" "$test_dir"; then
        print_status "Clone do reposit√≥rio privado testado com sucesso!" "success"
        
        cd "$test_dir"
        if [ -f "test_setup.py" ]; then
            echo ""
            print_status "Executando verifica√ß√µes de setup..." "info"
            python3 test_setup.py 2>/dev/null || print_status "Algumas verifica√ß√µes falharam (normal sem API configurada)" "warning"
        fi
        
        print_status "Estrutura do projeto verificada!" "success"
        cd - > /dev/null
    else
        print_status "Erro no teste de clone - verifique credenciais" "error"
    fi
fi

echo ""
print_status "üéØ Bot Trading Binance V5.1 deployed com sucesso!" "success"
print_status "üîí Reposit√≥rio privado protege seus dados e estrat√©gias!" "private"
print_status "üí∞ Lembre-se: Comece sempre no testnet!" "warning"

echo ""
print_status "Script de upload finalizado! üöÄ" "success"